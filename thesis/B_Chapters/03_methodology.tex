\chapter{Fedisky -- An ActivityPub Federation Sidecar for Bluesky PDS}

Fedisky is a sidecar service that a Bluesky PDS operator can deploy
alongside their PDS to enable federation with the Fediverse. It acts
as a bridge between the AT Protocol and ActivityPub, allowing users
on Mastodon instances to discover, follow, and interact with users on
the Bluesky PDS. Fedisky is designed to be a
lightweight and modular service that can be easily deployed and
maintained by PDS operators, without requiring any modifications to
the PDS itself. In this chapter, we will provide an overview of the
design and implementation of Fedisky, including its architecture,
data model, key components, and operational considerations.
Fedisky's source code is available on GitHub at
\url{https://github.com/msonnb/fedisky}.

\section{Overview}

\subsection{System Context}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{figures/c4-system-context.png}
  \caption{System Context Diagram showing how the Fedisky sidecar
  interacts with other systems and users.}
  \label{fig:system-context}
\end{figure}

\autoref{fig:system-context} shows the wider system context of
Fedisky and how it interacts with other systems and users. At the
core of the system is the PDS host, which runs both the ATProto PDS
and the Fedisky sidecar and is managed by the PDS operator. Fedisky
uses ATProto XRPC APIs to read and write records from the PDS, and
subscribe to its firehose endpoint to receive a real-time stream of
all new and updated records.

Fedisky exposes ActivityPub endpoints, which are used by
external Fediverse instances to deliver ActivityPub content to their
users and to receive incoming activities from the Fediverse. These
endpoints include a Webfinger endpoint for user discovery, an actor
endpoint for representing Bluesky users as ActivityPub actors, and an
inbox endpoint for receiving incoming activities from the Fediverse.

To fetch Bluesky records from users on other PDS instances, Fedisky
fetches records from the Bluesky AppView. In addition, Fedisky
periodically polls the ATProto Constellation
API\footnote{\url{https://constellation.microcosm.blue/}}, an
external service that aggregates and indexes backlinks across the
entire AT Protocol, allowing Fedisky to discover interactions such as
replies from users on other PDS instances, and federating them to the Fediverse.

\subsection{Technology Stack}

Fedisky is implemented in TypeScript and runs on Node.js. It stores
its data in a SQLite\footnote{\url{https://sqlite.org/}} database
using Kysely\footnote{\url{https://kysely.dev/}} as a type-safe query
builder. For federation functionality, Fedisky uses
Fedify\footnote{\url{https://fedify.dev/}}, a TypeScript library for
building ActivityPub servers.

Fedify provides a high-level API for defining ActivityPub actors,
registering dispatchers for handling incoming activities, and sending
outgoing activities to other Fediverse instances. It also handles the
underlying ActivityPub protocol primitives such as signing and
verifying HTTP requests, providing type-safe objects for Activity
Vocabulary
\footnote{\url{https://www.w3.org/TR/activitystreams-vocabulary/}}
such as \texttt{Create}, \texttt{Follow}, and \texttt{Note}. In
addition, Fedify includes scalability and reliability features such
as retry logic for failed deliveries, a message queue for processing
incoming and outgoing activities, and a KV-store for caching and
storing federation-related data such as public keys and remote actor
information.

\subsection{Subsystems}

Fedisky is structured around a set of loosely coupled subsystems,
each responsible for a distinct concern. These subsystems are wired
together at startup through a shared dependency injection container,
\ttt{AppContext}, which holds references to all major services: the
database, the PDS and AppView clients, the two bridge account
managers, the Fedify federation instance, and the logger. The main
service class, \ttt{APFederationService}, acts as the top-level
orchestrator: it initializes the database, provisions the bridge
accounts, starts the HTTP server, and conditionally launches the
three background processors described below.

\subsubsection{PDS and AppView Clients}

The \ttt{PDSClient} and \ttt{AppViewClient} modules provide thin
wrappers around the ATProto XRPC APIs. The PDS client is used for all
write operations and local record lookups as well as identity
resolution and blob retrieval. The AppView client is used exclusively
for read operations against the Bluesky AppView, such as fetching
posts from users on external PDS instances that are not accessible
through the local PDS. Separating the two clients reflects the
architectural distinction in AT Protocol between the PDS as the
authoritative data store and the AppView as a read-optimized aggregation layer.

\subsubsection{Firehose Processor}

The \ttt{FirehoseProcessor} subscribes to the PDS's
\ttt{com.atproto.sync.subscribeRepos} WebSocket endpoint and drives
the outbound federation pipeline. Each incoming frame is decoded from
its CBOR binary encoding and parsed into a structured commit event
containing the repository DID, a sequence number, and a list of
operations. The processor filters operations to only those affecting
collections for which a converter is registered, and skips events
originating from the bridge accounts to prevent bridging loops. For
create operations, it fetches the complete record from the PDS,
converts it into an ActivityPub activity using the converter
registry, and dispatches it to followers via Fedify. For delete
operations, it constructs the corresponding \ttt{Delete} or
\ttt{Undo} activity and dispatches it similarly. The processor also
add newly created local posts to the \ttt{ap\_monitored\_post} table
for later processing by the Constellation processor. On connection
loss, the processor waits five seconds before automatically reconnecting.

\subsubsection{Federation Layer}

The federation layer is implemented using Fedify as exposed via an
Express HTTP integration. It registers the WebFinger, actor, inbox,
outbox, followers, following, and NodeInfo endpoints described in
\autoref{sec:activitypub-endpoints}. Fedify handles the low-level
ActivityPub protocol concerns: verifying and signing HTTP requests,
and managing the message queue and KV store backed by a dedicated
SQLite database. The application layer registers dispatchers that
Fedify calls for each activity type or collection lookup, which in
turn delegate to the appropriate database queries or converter logic.

\subsubsection{Inbox Handlers}

The inbox module registers Fedify listeners for each supported
inbound activity type: \ttt{Follow}, \ttt{Undo}, \ttt{Delete},
\ttt{Like}, \ttt{Announce}, and \ttt{Create}. Each handler performs
the relevant database mutation and, in case of  \ttt{Follow},
dispatches an \ttt{Accept} response. The \ttt{Create(Note)} handler
additionally invokes the post converter to produce an ATProto record
and write it to the PDS via the Mastodon bridge account, as described
in \autoref{sec:core-inbound-federation}.

\subsubsection{Conversion Layer}

The conversion layer provides bidirectional translation between
ATProto records and ActivityPub objects. A
\ttt{RecordConverterRegistry} maps ATProto collection identifiers to
a converter instance implementing a common interface with
\ttt{toActivityPub} and \ttt{toRecord} methods. The post converter is
the most complex: in the outbound direction it transforms ATProto
facets into ActivityPub \ttt{Mention} tags, embeds media attachments,
converts self-labels into content warnings, and constructs the
correct \ttt{inReplyTo} chain. In the inbound direction it parses the
HTML content of an ActivityPub \ttt{Note}, reconstructs ATProto
facets, and prepends the attribution line. Supporting utilities
handle blob downloading and upload, HTML parsing, and label mapping.
A more detailed explanation of the conversion logic can be found in
\autoref{sec:conversion-layer}.

\subsubsection{Bridge Account System}
The two bridge accounts are managed by the
\ttt{MastodonBridgeAccountManager} and
\ttt{BlueskyBridgeAccountManager}, both subclassing an abstract
\ttt{BridgeAccountManager}. On startup, each manager checks the
database for stored credentials. If found, it attempts to refresh the
session, falling back to a password login if the refresh token is
expired. If no account record exists, it creates a new PDS account
using the configured handle and a random password. Once initialized,
each manager exposes the account's DID and a valid access token for
use in XRPC calls. The Mastodon bridge account is hidden from
ActivityPub discovery, while the Bluesky bridge account is exposed as
a regular actor.

\subsubsection{Constellation Processor}

The \ttt{ConstellationProcessor} runs as a periodic background job,
polling at a configurable interval (default 60 seconds). On each run,
it fetches a batch of up to 50 entries from the
\ttt{ap\_monitored\_post} table, which tracks local posts that have
been bridged to the Fediverse and may have received replies from
users on other PDS instances. For each post, it queries the
Constellation API for backlinks of type
\ttt{app.bsky.feed.post\:reply.parent.uri}, which identifies posts on
external PDS instances that reply to the monitored post. Each
discovered reply is checked against the \ttt{ap\_external\_reply}
deduplication table. New replies are fetched from the AppView,
converted into \ttt{Create(Note)} activities attributed to the
Bluesky bridge account, and delivered to the original post author's
followers via Fedify. The \ttt{ap\_external\_reply} record is then
created and the monitored post's \ttt{lastChecked} timestamp is updated.

\subsubsection{DM Notification Processor}

The \ttt{DMNotificationProcessor} polls the database at a
configurable interval (default 5 minutes) for likes and reposts that
have not yet triggered a notification and whose timestamp is older
than a configurable batch delay (default 10 minutes), ensuring that a
burst of engagements on a single post results in a single summary
message rather than individual notifications. Engagements are grouped
by post author and then by post, and a summary direct message is sent
to each author via the Bluesky Chat API using the Mastodon bridge
account as the sender. The message includes the display names of the
engaging Fediverse actors, resolved by fetching their ActivityPub
profiles, and a truncated excerpt of the post content.

\subsubsection{Database Layer}

All persistent state is stored in a SQLite database through Kysely. A
second SQLite database is used exclusively  by Fedify for its
internal KV store and message queue. Schema changes are manged
through numbered migration files, each exporting \ttt{up()} and
\ttt{down()} functions, which are applied automatically on service startup.

\section{Core Flows}

\subsection{Actor and Identity Discovery}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{figures/actor-discovery.png}
  \caption{Sequence diagram showing the actor and identity discovery
    flow when a Mastodon user tries to follow a Bluesky user on the
  PDS.}
  \label{fig:actor-discovery-sequence}
\end{figure}

When a Mastodon user tries to follow a federated Bluesky user on the
PDS, the Mastodon instance needs to discover the corresponding
ActivityPub actor for that user in order to send the follow request.
This flow is illustrated in \autoref{fig:actor-discovery-sequence}.
The Mastodon instance first queries the WebFinger endpoint with the
user's handle (e.g. \ttt{@alice@fedisky.social}) to discover the
corresponding ActivityPub actor URL. Fedisky first constructs the
ATProto handle by prepending the localpart (in this case,
\ttt{alice}) to the PDS's hostname (e.g. \ttt{fedisky.social}),
resulting in \ttt{alice.fedisky.social}. Note that the ActivityPub
handle domain and PDS domain do not have to match, but in this
example we use the same domain for simplicity. Fedisky then resolves
this handle using the PDS's \ttt{com.atproto.identity.resolveHandle}
API, which returns the corresponding DID if a matching user is found.
If a user is found, Fedisky constructs the ActivityPub actor URL
using the user's DID, resulting in
\ttt{https://fedisky.social/users/\{did\}}. This URL is returned to
the Mastodon instance in the WebFinger response, as shown in
\autoref{lst:webfinger-response}. In addition to the actor URL, the
response also includes references to the user's profile page and avatar.

\lstinputlisting[caption=WebFinger response for
  \ttt{@alice@fedisky.social},
label=lst:webfinger-response, style=jsonstyle]{listings/webfinger.json}

After receiving the WebFinger response, the Mastodon instance can
then query the actor endpoint to fetch the user's actor document,
which includes the user's profile information, public keys, and inbox
URLs. The object conforms to the Activity Vocabulary \ttt{Person}
type as defined in \cite{snellActivityVocabulary2017}. To construct
the actor document, Fedisky fetches the user's profile record form
the PDS using the \ttt{com.atproto.repo.getRecord} API. From the
profile record, Fedisky extracts the user's display name,
description, as well as avatar and banner images. Finally, Fedisky
retrieves the user's public keys from the database. If no keys exist
yet, Fedisky generates new RSA and Ed25519 key pairs and stores them
in the database.

In an effort to link accounts referring to the same identity,
\textcite{barrettBridgingIdentityAccount2025} proposes the use of
account links. In this approach, instead of relying on a separate
\enquote{meta account} that links all the user's accounts together,
accounts reference each other. Platforms can then use these references
to show highlighted links to these other accounts on different
platforms. Fedisky
follows this approach and includes the user's ATProto URI in the
\ttt{alsoKnownAs} field of the actor document, allowing Fediverse
instance to link the ActivityPub actor back to the original Bluesky
user and profile.

\subsection{Outbound: ATProto Post to ActivityPub Note}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{figures/outbound.png}
  \caption{Sequence diagram showing the outbound ATProto post to
  ActivityPub note conversion flow.}
  \label{fig:outbound}
\end{figure}

When a Bluesky user creates or deletes a post on the PDS, Fedisky
propagates these changes to the Fediverse so that Mastodon users
following that user receive updates. This flow is illustrated in the
sequence diagram in \autoref{fig:outbound}.

Fedisky receives real-time updates from the ATProto firehose, a
WebSocket stream that delivers commits as
CBOR\footnote{\url{https://atproto.com/specs/data-model}}-encoded
frames. Each frame contains repository operations (create, update,
or delete) along with metadata such as the repository DID and
sequence number. The firehose processor decodes the CBOR frame and
extracts the repository DID, operations, and sequence information.
It then filters operations to only process those that represent
record creation or deletions for collections that Fedisky can
convert to ActivityPub activities.

For create operations, the processor first fetches the complete
record from the PDS using the \ttt{com.atproto.repo.getRecord} API,
providing the repository DID, collection identifier (e.g.
\ttt{app.bsky.feed.post}), and record key. Once the record is
retrieved, the processor queries the record converter registry to
obtain the appropriate converter for the collection type. The
registry returns a converter instance that implements the
conversion logic for that specific ATProto record type.

The converter then transforms the ATProto record into an
ActivityPub \ttt{Create} activity containing a \ttt{Note} object.
During conversion, if the post is a reply, the converter queries
the database to look up the parent's post ActivityPub mapping,
which maps the ATProto URI to the corresponding ActivityPub object
ID and actor inbox. This mapping is necessary to construct the
\ttt{inReplyTo} property of the ActivityPub Note. If the post
contains embedded images or media, the converter builds the blob URLs
using the PDS's \ttt{com.atproto.sync.getBlob} API, and includes them
as attachments in the Note. Additionally, the converter transforms
plain text into HTML and ATProto self-labels into ActivityPub content
warnings if necessary. A detailed explanation of the conversion logic
can be found in \autoref{sec:conversion-layer}.

After conversion completes, Fedisky store the post mapping in the
database, recording the ATProto URI, author DID, and creation
timestamp. This mapping enables Fedisky to track which posts have
been federated and to handle subsequent operations like deletions. If
the post is a reply to a bridge account post (i.e. a post originally
created by a Fediverse user and relayed back to Bluesky), Fedisky
performs and additional step: It looks up the bridge post mapping to
retrieve the bridge actor's ID and inbox URL, then sends the
\ttt{Create} activity directly to that actor's inbox. This ensures
that the original Fediverse author receives notifications about
replies to their content.

Finally, Fedisky delivers the \ttt{Create} activity to all the
author's federated followers. The Fedify router queries the database
to retrieve the list of followers and for each follower, it
determines the appropriate inbox URL (either the follower's personal
inbox or their instance's shared inbox) and sends a request
containing the activity to that inbox endpoint. The activity is
signed using the author's private key to authenticate the request
according to ActivityPub's HTTP signature specification.

For delete operations, the flow is simpler. The processor constructs
either a \ttt{Delete} activity (for post deletions) or an \ttt{Undo}
activity (for undoing a like or repost) targeting the ActivityPub
object corresponding to the deleted ATProto record. If the deletion
is for a post, Fedisky also cleans up any associated database entries
related to that post. The \ttt{Delete} or \ttt{Undo} activity is then
delivered to all followers using the same inbox delivery mechanism as
create operations, ensuring that federated instances are notified of
the deletion.

\subsection{Inbound: ActivityPub Activity to ATProto
Record}\label{sec:core-inbound-federation}

\begin{figure}
  \centering
  \includegraphics[height=\dimexpr\textheight-38.2pt]{figures/inbound.png}
  \caption{Sequence diagram showing the inbound ActivityPub activity
  to ATProto record conversion flow.}
  \label{fig:inbound}
\end{figure}

\autoref{fig:inound} shows the inbound flow for incoming ActivityPub
activities. All incoming activities from the Fediverse are delivered
to Fedisky's
inbox endpoints by the remote ActivityPub instance. Fedify first
verifies the HTTP signature on each request and fetches the sending
actor from the network before dispatching the activity to the
appropriate handler. The handling logic then branches based on the
activity type as follows:

\subsubsection{Follow}

When Fedisky receives a \ttt{Follow} activity, it validates the
activity's required fields (identifier, actor, and object), then
parses the object URI to extract the target user's DID.
The follow relationship is persisted to the database, recording the
follower's actor URI and their personal and shared inbox URLs for
later use during activity delivery. Fedisky then sends an
\ttt{Accept(Follow)} activity back to the actor's inbox, completing
the handshake and activating the follow relationship on the remote instance.

\subsubsection{Undo(Follow), Undo(Like), Undo(Announce)}

These three undo variants are handled symmetrically. Fedisky locates
the original record in the database by actor URI or activity ID, and
removes it. No further action is required on the PDS.

\subsubsection{Delete(Actor)}

When an actor deletion is received, Fedisky performs a full cleanup
of all data associated with that actor. It removes all follow, like,
and repost records from the database. It then queries the database
for all post mappings belonging to that actor, iterating over each
bridged post and issuing a \ttt{com.atproto.repo.deleteRecord} call
via the bridge account client to remove the corresponding ATProto
record from the PDS. Finally, all remaining post mappings for the
actor are removed from the database.

\subsubsection{Delete(Note)}

For individual note deletions, Fedisky looks up the post mapping by
the ActivityPub note ID to retrieve the corresponding ATProto
collection and record key. If a mapping is found, Fedisky issues a
\ttt{com.atproto.repo.deleteRecord} call to the PDS to remove the
record, then removes the post mapping entry from the database.

\subsubsection{Like and Announce}

When a \ttt{Like} or \ttt{Announce} activity is received, Fedisky
parses the object URI to determine the target post's ATProto URI and
the author's DID. It then queries the PDS to verify that an account
with that DID is local to the PDS, discarding the activity if not. If
the post is confirmed to be local, the engagement is stored in the
database in the respective \ttt{ap\_like} or \ttt{ap\_repost} table,
recording the activity ID, post URI, and actor URI.

\subsubsection{Create(Note)}

The most involved inbound case handles incoming Fediverse replies to
posts that were originally bridged onto the PDS by the Mastodon
bridge account. Fedisky first validates the reply target and extracts
the parent post's ATProto URI from the path. It then fetches the
account for the post's author and retrieves the full parent post
record form the PDS using the \ttt{com.atproto.repo.getRecord} API,
obtaining the record's CID required for correct reply threading.
Next, Fedisky fetches the remote actor's profile and constructs an
attribution prefix in HTML (e.g. \enquote{@bob@mastodon.social
replied:}) to be prepended to the post content. The \ttt{Note} is
then passed to the post converter, which transforms it into an
ATPRoto \ttt{app.bsky.feed.post} record. After conversion, Fedisky
sets the reply references (\ttt{root} and \ttt{parent}), resolving
the CIDs of both the root and parent records so that the reply is
correctly threaded in the Bluesky client. The record is then written
to the PDS via the \ttt{com.atproto.repo.putRecord} API using the
bridge account client, which returns the new record's URI and CID.
Finally, Fedisky stores a post mapping in the database, recording the
ATProto URI, the original ActivityPub note ID, the actor URI, and the
actor's inbox URL, enabling future operations such as deletions to
locate the bridged post.

\section{Data Model}

\subsection{Database Schema}

\subsubsection{Identity \& Cryptography}

\begin{itemize}
  \item \ttt{ap\_key\_pair} -- Stores the cryptographic key pairs
    used for HTTP signature signing. Each local PDS user gets two key
    pairs generated on first access: one RSA for compatibility with older
    ActivityPub implementations, and one Ed25519 for modern servers.
    The keys are stored as PEM-encoded strings.
  \item \ttt{ap\_bridge\_account} and
    \ttt{ap\_bluesky\_bridge\_account} -- Singleton tables that store
    the credentials for the two bridge accounts (see
    \autoref{sec:bridge-account-system}).
\end{itemize}

\subsubsection{Social Graph}

\begin{itemize}
  \item \ttt{ap\_follow} -- Records which ActivityPub actors follow
    which local PDS users. This is the core table for activity
    delivery, as it determines which users should receive which
    activities based on their follow relationships. It stores the
    follower's inbox URL and shared inbox URL for efficient delivery.
\end{itemize}

\subsubsection{Content Mapping}

\begin{itemize}
  \item \ttt{ap\_post\_mapping} -- Maps ATProto post URIs to their
    original ActivityPub Note IDs and author information. This table
    is essential for correct reply threading.
  \item \ttt{ap\_external\_reply} -- Stores external Bluesky replies
    from other PDS instances that have been federated via the
    Constellation processor. Primarily for deduplication as the
    Constellation API is polled repeatedly.
  \item \ttt{ap\_monitored\_post} -- The work queue for the
    Constellation processor, which tracks which posts need to be
    checked for new external replies.
\end{itemize}

\subsubsection{Engagement Tracking}

\begin{itemize}
  \item \ttt{ap\_like} and \ttt{ap\_repost} -- Stores incoming
    ActivityPub \ttt{Like} and \ttt{Announce} activities targeting
    local posts. The tables main purpose are to track engagements for
    display (e.g. showing like counts) and batching engagement for DM
    notifications.
\end{itemize}

\subsection{Migration Strategy}

Migrations are implemented using Kysely's built-in migration system,
which allows us to define schema changes in a type-safe manner. Each
migration is defined as a numbered TypeScript file exporting
\ttt{up()} and \ttt{down()} functions. On service startup, pending
migrations are automatically applied in order. This approach allows
us to evolve the database schema over time while ensuring data
integrity and providing a clear history of schema changes.

\section{Bridge Account System}\label{sec:bridge-account-system}

\subsection{Why Two Bridge Accounts?}

Fedisky uses two special \enquote{bridge accounts} to facilitate
bridging between the AT Protocol and ActivityPub. The first is the
Mastodon bridge account, which is hidden from users in
ActivityPub and is used to post incoming Fediverse replies as ATProto
posts on the PDS, so that they appear in the Bluesky user's thread
and can be replied to and interacted with like normal posts. Its
handle and display name can be configured by the operator, with the
default being \ttt{mastodon.\{hostname\}} and \enquote{Mastodon
Bridge} respectively.

The second one is the Bluesky bridge account, which is used to
federate replies from Bluesky users on other PDS instances to the
Fediverse. This allows users on Mastodon to see and interact with
replies from users on other PDS instances, which would otherwise be
invisible to the Fediverse. The Bluesky bridge account's default
handle is \ttt{bluesky.\{hostname\}} and display name is
\enquote{Bluesky Bridge}, again configurable by the operator via
environment variables.

\subsection{Attribution Model}

Since both bridge accounts post content on behalf on users and do not
carry any user identity in their handle or display name, we need to
ensure proper attribution of content to the original authors. For
incoming Fediverse replies posted by the Mastodon bridge account, we
include the original author's handle in the first line of the post
content, e.g. \enquote{@bob@mastodon.social replied:}, followed by
the actual reply content. Similarly, federated Bluesky replies from
third-party PDS instances sent by the Bluesky bridge account include
an attribution line with the original author's Bluesky handle, e.g.
\enquote{alice.bsky.social replied:}, followed by the reply content.
In both cases, the handle is a clickable link to the original
profile, allowing users to easily find and follow the original author
if they wish. Additionally, since Mastodon content is formatted in
HTML, we need to ensure all content is properly escaped to prevent
Cross-Site-Scripting (XSS) vulnerabilities.

\section{Inbound Federation}

\subsection{ActivityPub Endpoints}\label{sec:activitypub-endpoints}

Using Fedify together with its Express HTTP
integration\footnote{\url{https://fedify.dev/manual/integration\#express}},
we expose the following ActivityPub endpoints:

\begin{itemize}
  \item \ttt{GET /.well-known/webfinger} \\
    The WebFinger endpoint
    for user discovery. When a Mastodon instance encounters a handle
    such as \ttt{@alice@fedisky.social}, it will query this endpoint
    to discover the corresponding ActivityPub actor URL. Fedisky
    resolves the handle using the PDS's
    \ttt{com.atproto.identity.resolveHandle} API, and if a matching
    PDS user is found, constructs an ActivityPub actor URL using the
    user's DID as the unique identifier, i.e.
    \ttt{https://fedisky.social/users/\{did\}}.
  \item \ttt{GET /users/\{did\}} \\
    The actor endpoint. Returns an ActivityPub \ttt{Person} object
    representing the Bluesky user with the given DID. Includes the
    user's inbox, outbox, followers, and following URIs, as well as
    their public keys (both RSA and Ed25519), and profile information
    such as display name and avatar. It also includes a
    \ttt{alsoKnownAs} field with the user's ATProto URI, in order to
    link the ActivityPub actor back to the original PDS user and
    identity. The Mastodon bridge account does not have an
    ActivityPub actor representation.
  \item \ttt{POST /users/\{did\}/inbox} \\
    The inbox endpoint for receiving incoming activities from the
    Fediverse. This is where we receive activities such as
    \ttt{Follow} requests. When an activity is received, we verify
    the HTTP signature to ensure it is from a trusted source, and
    then dispatch it to the appropriate handler based on the activity type.
  \item \ttt{POST /inbox} \\
    A server-wide shared inbox endpoint that some Fediverse instances
    support for
    more efficient delivery. Fedisky also supports this endpoint for
    incoming activities, and dispatches them in the same way as the
    user-specific inbox.
  \item \ttt{GET /users/\{did\}/outbox} \\
    Paginated collection of posts, likes, and reposts, aggregated
    from the PDS using its \ttt{com.atproto.repo.listRecords} API.
    This allows Mastodon instance to fetch the user's content and
    engagements for display on their profile and timelines.
  \item \ttt{GET /users/\{did\}/followers} and \ttt{GET
    /users/\{did\}/following} \\
    Paginated collections of followers and following, based on the
    \ttt{ap\_follow} table. This allows Mastodon instances to display
    the user's followers and following lists, and to determine which
    users they should receive activities from.
  \item \ttt{GET /posts/\{uri\}} \\
    Endpoint for fetching a specific post by its ATProto URI, used by
    Mastodon instances to fetch the content and metadata of a post
    when displaying it or when a user clicks on a link to the post.
    Fedisky resolves the ATProto URI using the PDS's
    \ttt{com.atproto.repo.getRecord} API, and returns an ActivityPub
    Note object with the post content, author information, and any
    media attachments.
  \item \ttt{GET /nodeinfo/2.1} \\
    The NodeInfo\footnote{\url{https://nodeinfo.diaspora.software/}}
    endpoint providing metadata about the Fedisky
    instance, such as software name and version, and supported
    features. This is used by Mastodon instances to determine
    compatibility and capabilities of the Fedisky bridge.
\end{itemize}

\subsection{Inbox Processing}

\subsection{Reply Bridging}

\subsection{Post Mapping for Reply Threading}

\subsection{Engagement Notifications}

\section{Conversion Layer}\label{sec:conversion-layer}

\subsection{Post Converter}

\subsection{HTML \texorpdfstring{$\leftrightarrow$}{<->} Rich Text}

\subsection{Media Handling}

\subsection{Edge Cases}

\section{Observability \& Operations}

\subsection{Wide Events Logging}

\subsection{Testing}

\subsubsection{Unit Tests}

\subsubsection{End-to-End Tests}

\subsection{Deployment}