\chapter{Fedisky -- An ActivityPub Federation Sidecar for Bluesky PDS}

Fedisky is a sidecar service that a Bluesky PDS operator can deploy
alongside their PDS to enable federation with the Fediverse. It acts
as a bridge between the AT Protocol and ActivityPub, allowing users
on Mastodon instances to discover, follow, and interact with users on
the Bluesky PDS. Fedisky is designed to be a
lightweight and modular service that can be easily deployed and
maintained by PDS operators, without requiring any modifications to
the PDS itself. In this chapter, we will provide an overview of the
design and implementation of Fedisky, including its architecture,
data model, key components, and operational considerations.
Fedisky's source code is available on GitHub at
\url{https://github.com/msonnb/fedisky}.

\section{Overview}

\subsection{System Context}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{figures/c4-system-context.png}
  \caption{System Context Diagram showing how the Fedisky sidecar
  interacts with other systems and users.}
  \label{fig:system-context}
\end{figure}

\autoref{fig:system-context} shows the wider system context of
Fedisky and how it interacts with other systems and users. At the
core of the system is the PDS host, which runs both the ATProto PDS
and the Fedisky sidecar and is managed by the PDS operator. Fedisky
uses ATProto XRPC APIs to read and write records from the PDS, and
subscribe to its firehose endpoint to receive a real-time stream of
all new and updated records.

Fedisky exposes ActivityPub endpoints, which are used by
external Fediverse instances to deliver ActivityPub content to their
users and to receive incoming activities from the Fediverse. These
endpoints include a Webfinger endpoint for user discovery, an actor
endpoint for representing Bluesky users as ActivityPub actors, and an
inbox endpoint for receiving incoming activities from the Fediverse.

To fetch Bluesky records from users on other PDS instances, Fedisky
fetches records from the Bluesky AppView. In addition, Fedisky
periodically polls the ATProto Constellation
API\footnote{\url{https://constellation.microcosm.blue/}}, an
external service that aggregates and indexes backlinks across the
entire AT Protocol, allowing Fedisky to discover interactions such as
replies from users on other PDS instances, and federating them to the Fediverse.

\subsection{Technology Stack}

Fedisky is implemented in TypeScript and runs on Node.js. It stores
its data in a SQLite\footnote{\url{https://sqlite.org/}} database
using Kysely\footnote{\url{https://kysely.dev/}} as a type-safe query
builder. For federation functionality, Fedisky uses
Fedify\footnote{\url{https://fedify.dev/}}, a TypeScript library for
building ActivityPub servers.

Fedify provides a high-level API for defining ActivityPub actors,
registering dispatchers for handling incoming activities, and sending
outgoing activities to other Fediverse instances. It also handles the
underlying ActivityPub protocol primitives such as signing and
verifying HTTP requests, providing type-safe objects for Activity
Vocabulary
\footnote{\url{https://www.w3.org/TR/activitystreams-vocabulary/}}
such as \texttt{Create}, \texttt{Follow}, and \texttt{Note}. In
addition, Fedify includes scalability and reliability features such
as retry logic for failed deliveries, a message queue for processing
incoming and outgoing activities, and a KV-store for caching and
storing federation-related data such as public keys and remote actor
information.

\subsection{High-Level Data Flow}

\subsection{Component Overview}

\subsection{Dependency Injection}

\section{Data Model}

\subsection{Database Schema}

\subsubsection{Identity \& Cryptography}

\begin{itemize}
  \item \ttt{ap\_key\_pair} -- Stores the cryptographic key pairs
    used for HTTP signature signing. Each local PDS user gets two key
    pairs generated on first access: one RSA for compatibility with older
    ActivityPub implementations, and one Ed25519 for modern servers.
    The keys are stored as PEM-encoded strings.
  \item \ttt{ap\_bridge\_account} and
    \ttt{ap\_bluesky\_bridge\_account} -- Singleton tables that store
    the credentials for the two bridge accounts (see
    \autoref{sec:bridge-account-system}).
\end{itemize}

\subsubsection{Social Graph}

\begin{itemize}
  \item \ttt{ap\_follow} -- Records which ActivityPub actors follow
    which local PDS users. This is the core table for activity
    delivery, as it determines which users should receive which
    activities based on their follow relationships. It stores the
    follower's inbox URL and shared inbox URL for efficient delivery.
\end{itemize}

\subsubsection{Content Mapping}

\begin{itemize}
  \item \ttt{ap\_post\_mapping} -- Maps ATProto post URIs to their
    original ActivityPub Note IDs and author information. This table
    is essential for correct reply threading.
  \item \ttt{ap\_external\_reply} -- Stores external Bluesky replies
    from other PDS instances that have been federated via the
    Constellation processor. Primarily for deduplication as the
    Constellation API is polled repeatedly.
  \item \ttt{ap\_monitored\_post} -- The work queue for the
    Constellation processor, which tracks which posts need to be
    checked for new external replies.
\end{itemize}

\subsubsection{Engagement Tracking}

\begin{itemize}
  \item \ttt{ap\_like} and \ttt{ap\_repost} -- Stores incoming
    ActivityPub \ttt{Like} and \ttt{Announce} activities targeting
    local posts. The tables main purpose are to track engagements for
    display (e.g. showing like counts) and batching engagement for DM
    notifications.
\end{itemize}

\subsection{Migration Strategy}

Migrations are implemented using Kysely's built-in migration system,
which allows us to define schema changes in a type-safe manner. Each
migration is defined as a numbered TypeScript file exporting
\ttt{up()} and \ttt{down()} functions. On service startup, pending
migrations are automatically applied in order. This approach allows
us to evolve the database schema over time while ensuring data
integrity and providing a clear history of schema changes.

\section{Bridge Account System}\label{sec:bridge-account-system}

\subsection{Why Two Bridge Accounts?}

Fedisky uses two special \enquote{bridge accounts} to facilitate
bridging between the AT Protocol and ActivityPub. The first is the
Mastodon bridge account, which is hidden from users in
ActivityPub and is used to post incoming Fediverse replies as ATProto
posts on the PDS, so that they appear in the Bluesky user's thread
and can be replied to and interacted with like normal posts. Its
handle and display name can be configured by the operator, with the
default being \ttt{mastodon.\{hostname\}} and \enquote{Mastodon
Bridge} respectively.

The second one is the Bluesky bridge account, which is used to
federate replies from Bluesky users on other PDS instances to the
Fediverse. This allows users on Mastodon to see and interact with
replies from users on other PDS instances, which would otherwise be
invisible to the Fediverse. The Bluesky bridge account's default
handle is \ttt{bluesky.\{hostname\}} and display name is
\enquote{Bluesky Bridge}, again configurable by the operator via
environment variables.

\subsection{Account Lifecycle}

\subsection{Attribution Model}

\section{Outbound Federation}

\subsection{Firehose Processor}

\subsection{Record Conversion}

\subsection{Activity Delivery}

\subsection{External Reply Discovery}

\section{Inbound Federation}

\subsection{ActivityPub Endpoints}

\subsection{Inbox Processing}

\subsection{Reply Bridging}

\subsection{Post Mapping for Reply Threading}

\subsection{Engagement Notifications}

\section{Conversion Layer}

\subsection{Post Converter}

\subsection{HTML \texorpdfstring{$\leftrightarrow$}{<->} Rich Text}

\subsection{Media Handling}

\subsection{Edge Cases}

\section{Observability \& Operations}

\subsection{Wide Events Logging}

\subsection{Testing}

\subsubsection{Unit Tests}

\subsubsection{End-to-End Tests}

\subsection{Deployment}